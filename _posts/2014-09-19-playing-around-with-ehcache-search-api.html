---
layout: post
title: Playing around with the Ehcache Search API
date: '2014-09-19T18:36:00.000+02:00'
author: Niko KÃ¶bler
tags:
- '#ehcache'
- '#search'
- '#java'
- '#cache'
modified_time: '2014-09-19T18:36:05.911+02:00'
blogger_id: tag:blogger.com,1999:blog-9037000245514999222.post-3441100103765841924
blogger_orig_url: http://blog.n-k.de/2014/09/playing-around-with-ehcache-search-api.html
---

In the last few days, I had to cope with a requirement with one of my customers:<br /><ul><li>Let's say, there is an application which produces about 200 events per second, that's not that much.</li><li>These events are being pumped into my middleware (actually it's not "mine", but the one I'm responsible for).</li><li>An event can have several attributes, but the most important two are the timestamp and the category of an event.</li><li>Third party applications requesting events from the middleware by a cutoff timestamp and one ore more categories.</li><li>Theses requests may be sent in "short" intervals of 1 to 5 minutes, so the gap between the requested cutoff timestamp and the current time may be small and only a few events will be affected.</li><li>But, however, there may be a bigger gap since the last request of a 3rd party application, so the maximum timestamp can be up to two hours.</li><li>A request should be completed in about 5 seconds.</li><li>Events older than 2 hours are not relevant.</li></ul>Ok, so let's see, what we have so far:<br /><ul><li>~200 events per second in two hours are about 1.500.000 events in total I have to fight with.</li><li>The events are not really pumped into the middleware, actually it's a polling-mechanism because of source systems limitations.</li><li>The requests of the 3rd party applications are REST-like requests (it's not a real REST approach).</li><li>A Java EE application server, running Java EE 6 with JDK 7.</li><li>So far, no persistence layer is used, but</li><li>Ehcache is used for caching purposes.</li></ul>Not bad at all, but also not a perfect world!<br /><br />Storing all the events in a (relational) database didn't seem reasonable to me. To many inserts, to many selects, manually house-keeping of old events an deleting them, permanently indexing.... not a good way. Discard!<br />Perhaps a NoSql store? Ok, maybe... But which? <a href="http://redis.io/" target="_blank">Redis</a> might be a good choice for that, but hey, I've to perform a search in all these events, looking for elements greater than a cutoff timestamp and equal to a category.<br /><br />So, what about using <a href="http://www.elasticsearch.org/" target="_blank">Elasticsearch</a>? Mmmhh, not bad, but overkill perhaps? I've only to cope a small amount of objects, time intervall and attributes to search for. Perhaps even <a href="http://lucene.apache.org/" target="_blank">Lucene</a> is enough. Sure, it will be enough. But what about this <a href="http://ehcache.org/" target="_blank">Ehcache</a>, which is already available in the middleware?<br /><br />So far, I only noticed Ehcache as a caching provider when using an ORM, like Hibernate. But nothing more. "Cache" in my mind was related to <a href="http://infinispan.org/" target="_blank">Infinispan</a> or <a href="http://hazelcast.org/" target="_blank">Hazelcast</a>...<br /><br />I played around with it, putting objects into the cache, getting them from the cache, everythis is very fast, because I've used the on-heap cache only. Disk usage is also fast, but, of course, slower than only using the memory (this is due to serialization/deserialization of the elements). There's an off-heap option, called "<a href="http://terracotta.org/products/bigmemory" target="_blank">BigMemory</a>", available for single or distributed caches - if caches grow bigger than you GC can handle ;-) But this BigMemory option is not free of charge, it's commercial. So no option for my customer.<br /><br />I started calculating... An average event has the size of 600 bytes (the Java object stored in the on-heap cache). In total we get a cache size of 850MB - that's not that much. Java on-heap caches are ok up to 4GB of memory, this also can be handled by the GC. Everything bigger, may slow down the system. (Hint: you can save lot's of memory, if you don't use objects like java.util.Date in your object, but convert these attributes to, e.g. integer values, this is much more memory efficient and can also be handled while searching!)<br /><br />After having a deeper look into the (very good)&nbsp;<a href="http://ehcache.org/documentation" target="_blank">documentation of Ehcache</a> (deeper means "<i>more than the getting started page</i>"!), I stumbled upon the <a href="http://ehcache.org/documentation/apis/search" target="_blank"><b>Ehcache Search API</b></a>. Wow! Sounds promising! Simply specify your cache as searchable in your configuration and, for performance reasons, specify these attributes, you're gonna searching for. Then, create a query using the attributes, execute it, get the results and be happy! :-)<br /><pre class="prettyprint">&lt;cache name="events" maxEntriesLocalHeap="1500000"&gt;<br />  &lt;searchable keys="false" values="false"&gt;<br />    &lt;searchAttribute name="date"/&gt;<br />    &lt;searchAttribute name="category"/&gt;<br />  &lt;/searchable&gt;<br />&lt;/cache&gt;<br /></pre><pre class="prettyprint">Cache cache = CacheManager.getInstance().getCache("events");<br />Attribute<integer> date = cache.getSearchAttribute("date");<br />Attribute<string> category = cache.getSearchAttribute("category");<br />Query query = cache.createQuery().includeValues()<br />                  .addCriteria(date.ge(myDateValueAsInteger))<br />                  .addCriteria(category.eq(myCategoryValue))<br />                  .end();<br />Results eventsResult = query.execute();<br />int eventsTotalCount = results.size();<br /></string></integer></pre>How they made it? Is there a search-index like in Lucene? Or do they simply iterate through all elements in the cache and compare the attribute values?<br />They do both! But depending on how you use Ehcache!<br /><br />If you use Ehcache, like I do, in a standalone, on-heap only mode, no index is used and all the elements are touched while searching. Because all elements are in memory and no deserialization has to take place, this can be achieved pretty fast. <b>One million elements can be touched in under 1 second!</b> And this seams to be very linear and stable. So, my requirement with up to 1,5 million elements can be handled in less than 2 seconds. This is in fact less than the requested 5 seconds, but this is only the search process. The result still have to be fetched and serialized to JSON for the REST response. But this is another task.<br /><br />If you use Ehcache with BigMemory, there is an index created, using Lucene in the underground. Java objects in the off-heap have to be serialized and can't be searched directly, so there's need for an index. I didn't test that option, but as Lucene is used, I'm sure, this is also done with high- performance as other Lucene based products (like Elasticsearch).<br /><br />More on the implementation and performance you can <a href="http://ehcache.org/documentation/apis/search#implementation-and-performance" target="_blank">read here</a>!<br /><br /><a href="https://github.com/dasniko/ehcache-search-example" target="_blank">I created a small demo project on GitHub</a>, not using events, but using fake-data Person objects, putting 1 million into the cache and performing some search queries. It strongly depends on the power of your computer and how your cache is being used before (warmup), if the queries perform better or not. The examples are unit-tests, so just clone the repository and run "<i>mvn test</i>"!<br /><br />Ah, and what about the requirement that events older than two hours are not interesting?<br />That's more than easy. Simply configure a <i>timeToLive </i>attribute, or, as I solved it, don't take care of the age of an element, just specify FIFO (first-in-first-out) as the expiry strategy, set maximum size of elements to 1,5 million, and you are done! ;-)