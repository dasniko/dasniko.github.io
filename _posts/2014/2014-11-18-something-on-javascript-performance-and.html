---
title: Something on JavaScript Performance and Benchmarking
tags:
- dynjs
- v8
- nodejs
- nashorn
- javascript
---

Inspired by the <a href="http://eclipsesource.com/blogs/2014/11/17/highly-efficient-java-javascript-integration/" target="_blank">new J2V8 JavaScript runtime by Ian Bull</a>&nbsp;and his benchmark against Rhino, I considered finally to do some benchmarking and performance tests with the JS runtimes I'm currently working with:<br /><b><a href="https://blogs.oracle.com/nashorn/entry/welcome_to_the_nashorn_blog" target="_blank">Nashorn</a> </b>and <b><a href="http://dynjs.org/" target="_blank">DynJS</a> </b>as JS runtimes on top of the JVM, <b><a href="https://developer.mozilla.org/de/docs/Rhino" target="_blank">Rhino</a> </b>as comparison to the past and <b><a href="https://code.google.com/p/v8/" target="_blank">V8</a>/Nod</b>e as a native runtime.<br /><br /><b>The test environment:</b><br />Virtual Machine running (headless) Ubuntu Linux 12.04 LTS 32bit, 1 CPU, 1GB RAM<br />(Host: Win7 64bit, i7 Quad-Core, 8GB RAM)<br /><br /><b>The test script:</b><br />I took exactly the fibonacci-/array-function Ian Bull used for his benchmark against Rhino. Then, I called the function 1, 10.000 and 100.000 times and measured the time. I know that this is not exactly correct, because when running the 10k and 100k loops, the JS engine is already warmed up. But, I ran the same script on all plattforms:<br /><pre class="prettyprint">var fibonacci = function() {<br /> var i;<br /> var fib = [];<br /> fib[0] = 1;<br /> fib[1] = 1;<br /> for(i = 2; i &lt;= 100; i++) {<br />  fib[i] = fib[i-2] + fib[i-1];<br /> }<br /> fib;<br />};<br /><br />var fibExec = function(times) {<br /> var start = new Date().getTime();<br /> for (n = 0; n &lt; times; n++) {<br />  fibonacci();<br /> }<br /> var duration = times + ": " + (new Date().getTime() - start);<br /> print(duration);<br />};<br /><br />fibExec(1);<br />fibExec(10000);<br />fibExec(100000);</pre><br /><b>The results:</b><br />First of all, let the numbers speak for themselves, then, I have some comments:<br /><br /><table style="width: 100%;"><thead><tr> <th>JS Runtime</th><th>Version</th><th>1</th><th>10k</th><th>100k</th></tr></thead><tbody><tr><td>V8/Node</td><td>v0.10.33</td><td style="text-align: right;">1ms</td><td style="text-align: right;">35ms</td><td style="text-align: right;">284ms</td></tr><tr><td>Rhino</td><td>v1.7R4 on J8u25</td><td style="text-align: right;">6ms</td><td style="text-align: right;">265ms</td><td style="text-align: right;">2232ms</td></tr><tr><td>Nashorn</td><td>Java 8u25</td><td style="text-align: right;">55ms</td><td style="text-align: right;">252ms</td><td style="text-align: right;">1606ms</td></tr><tr><td>Nashorn</td><td>Java 8u40 (ea build b12)</td><td style="text-align: right;">52ms</td><td style="text-align: right;">215ms</td><td style="text-align: right;">1064ms</td></tr><tr><td>DynJS</td><td>v0.3.0 on J8u25</td><td style="text-align: right;">44ms</td><td style="text-align: right;">6406ms</td><td style="text-align: right;">63047ms</td></tr><tr><td>DynJS</td><td>v0.3.0 on J8u40 (b12)</td><td style="text-align: right;">38ms</td><td style="text-align: right;">6058ms</td><td style="text-align: right;">58229ms</td></tr></tbody></table><br /><b>Some thoughts and comments:</b><br /><ul><li>Interesting thing, that V8 is so much faster. I expected that it is faster, but not that much. I'm impressed, there's some work for the JVM runtimes to do.</li><li>Rhino ist much faster than Nashorn when the engine is cold, after warming-up, Nashorn is performing better (ok, this is well known, nothing new - but why? and why it doesn't get fixed? even DynJS performs here better)</li><li>The next Java 8 update 40 release will come with performance improvements in Invokedynamic between 17 and 51% for Nashorn. That's quite a lot. I like! :-)</li><li>Unfortunately DynJS only uses&nbsp;+/- 10% in average of this performance improvement, although it also uses invokedynamic.</li><li>DynJS is up to 20% faster when executing the fibonacci function only 1 time, but much, much slower when executing it 10k times. And I don't know what the hell they are doing at the 100k loop...!?</li></ul><br />So, there's some homework to do for the Nashorn and DynJS teams, if they want to compete with V8 on performance! But still I like theses JavaScript JVM approaches very much! IMO it's more powerful when it comes to enterprise integration than any native solution. Performance is not the only thing that matters!
